#!/usr/bin/env python3
"""
üéµ SON1KVERS3 - Ollama-Suno Proxy
Sistema inteligente que usa Ollama como intermediario para comunicaci√≥n robusta con Suno
"""

import asyncio
import requests
import json
import time
import logging
from typing import Dict, Any, Optional, List
from datetime import datetime
import os
from pathlib import Path

# Importar sistema de credenciales avanzado
from credential_manager import credential_manager, get_stealth_credentials
from stealth_suno_wrapper import generate_music_stealth, validate_suno_stealth

# Configurar logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

class OllamaSunoProxy:
    """Proxy inteligente Ollama-Suno para comunicaci√≥n robusta"""
    
    def __init__(self):
        self.ollama_url = "http://localhost:11434"
        self.suno_credentials = None
        self.audio_dir = Path("generated_audio")
        self.audio_dir.mkdir(exist_ok=True)
        
    async def check_ollama_health(self) -> bool:
        """Verificar que Ollama est√© funcionando"""
        try:
            response = requests.get(f"{self.ollama_url}/api/version", timeout=3)
            return response.status_code == 200
        except:
            return False
    
    async def _translate_to_english(self, text: str) -> str:
        """Traducir texto del espa√±ol al ingl√©s usando diccionario b√°sico"""
        
        if not text or not text.strip():
            return text
        
        # Detectar si ya est√° en ingl√©s (b√°sico)
        english_words = ['the', 'and', 'with', 'song', 'music', 'guitar', 'piano', 'drums', 'bass', 'rock', 'pop', 'jazz', 'folk', 'classical', 'electronic', 'acoustic', 'electric', 'soft', 'hard', 'fast', 'slow', 'happy', 'sad', 'energetic', 'calm', 'beautiful', 'epic', 'melodic', 'rhythmic']
        
        # Si contiene palabras en ingl√©s, asumir que ya est√° en ingl√©s
        text_lower = text.lower()
        if any(word in text_lower for word in english_words):
            return text
        
        # Diccionario de traducci√≥n b√°sico
        translations = {
            # G√©neros musicales
            'm√∫sica': 'music',
            'canci√≥n': 'song',
            'balada': 'ballad',
            'rock': 'rock',
            'pop': 'pop',
            'jazz': 'jazz',
            'folk': 'folk',
            'cl√°sica': 'classical',
            'electr√≥nica': 'electronic',
            'ac√∫stica': 'acoustic',
            'rom√°ntica': 'romantic',
            'energ√©tica': 'energetic',
            'triste': 'sad',
            'feliz': 'happy',
            'calma': 'calm',
            '√©pica': 'epic',
            'mel√≥dica': 'melodic',
            'r√≠tmica': 'rhythmic',
            
            # Instrumentos
            'guitarra': 'guitar',
            'piano': 'piano',
            'bater√≠a': 'drums',
            'bajo': 'bass',
            'viol√≠n': 'violin',
            'saxof√≥n': 'saxophone',
            'trompeta': 'trumpet',
            'flauta': 'flute',
            'arm√≥nica': 'harmonica',
            'banjo': 'banjo',
            
            # Descriptores
            'suave': 'soft',
            'fuerte': 'strong',
            'r√°pida': 'fast',
            'lenta': 'slow',
            'hermosa': 'beautiful',
            'incre√≠ble': 'amazing',
            'perfecta': 'perfect',
            'genial': 'great',
            'fant√°stica': 'fantastic',
            'incre√≠ble': 'incredible',
            
            # Acciones musicales
            'cantar': 'sing',
            'tocar': 'play',
            'bailar': 'dance',
            'escuchar': 'listen',
            'disfrutar': 'enjoy',
            'rockear': 'rock',
            'vibrar': 'vibe',
            'relajarse': 'relax',
            'celebrar': 'celebrate',
            'inspirar': 'inspire'
        }
        
        # Traducir palabra por palabra
        words = text.lower().split()
        translated_words = []
        
        for word in words:
            # Limpiar palabra de puntuaci√≥n
            clean_word = word.strip('.,!?;:')
            if clean_word in translations:
                translated_words.append(translations[clean_word])
            else:
                translated_words.append(word)
        
        translation = ' '.join(translated_words)
        
        if translation != text:
            logger.info(f"üåê Traducido: '{text}' ‚Üí '{translation}'")
            return translation
        
        # Fallback: devolver texto original
        return text
    
    def setup_suno_credentials(self, session_id: str, cookie: str, token: str = None):
        """Configurar credenciales de Suno"""
        self.suno_credentials = {
            "session_id": session_id,
            "cookie": cookie,
            "token": token,
            "last_used": datetime.now()
        }
        logger.info("‚úÖ Credenciales de Suno configuradas en proxy")
    
    async def generate_music_via_ollama(self, prompt: str, lyrics: str = "", style: str = "synthwave") -> Dict[str, Any]:
        """Generar m√∫sica usando Ollama como intermediario inteligente"""
        
        # 1. Verificar Ollama
        if not await self.check_ollama_health():
            logger.error("‚ùå Ollama no disponible")
            return self._fallback_response("Ollama no disponible")
        
        # 2. Usar Ollama para optimizar el prompt para Suno
        optimized_prompt = await self._optimize_prompt_with_ollama(prompt, lyrics, style)
        
        # 3. Intentar generaci√≥n con Suno usando el prompt optimizado
        if self.suno_credentials:
            suno_result = await self._try_suno_generation(optimized_prompt, lyrics, style)
            if suno_result["success"]:
                return suno_result
        
        # 4. Fallback: Generar m√∫sica usando Ollama directamente
        return await self._generate_with_ollama_fallback(optimized_prompt, lyrics, style)
    
    async def _optimize_prompt_with_ollama(self, prompt: str, lyrics: str, style: str) -> str:
        """Usar Ollama para optimizar y traducir el prompt para Suno"""
        
        # Primero traducir al ingl√©s si es necesario
        english_prompt = await self._translate_to_english(prompt)
        english_lyrics = await self._translate_to_english(lyrics) if lyrics else ""
        
        system_prompt = f"""Eres un experto en generaci√≥n musical. 
Crea un prompt natural y descriptivo en INGL√âS para generar m√∫sica:

Prompt original: {english_prompt}
Letra: {english_lyrics}
Estilo: {style}

Genera un prompt optimizado en INGL√âS que:
1. Use lenguaje natural y descriptivo
2. Incluya elementos musicales reales (instrumentos, tempo, mood)
3. Sea espec√≠fico pero no t√©cnico
4. Tenga m√°ximo 150 caracteres
5. Suene como una descripci√≥n musical normal en ingl√©s

Ejemplos de buenos prompts en ingl√©s:
- "acoustic guitar folk song with warm vocals"
- "upbeat pop with electric guitar and drums"
- "soft piano ballad with strings"
- "rock song with heavy guitar riffs"
- "jazz piano with smooth saxophone"
- "country song with banjo and harmonica"

Responde SOLO con el prompt optimizado en ingl√©s, sin explicaciones."""

        try:
            response = requests.post(
                f"{self.ollama_url}/api/generate",
                json={
                    "model": "llama3.1:latest",
                    "prompt": system_prompt,
                    "stream": False,
                    "options": {
                        "temperature": 0.7,
                        "top_p": 0.9,
                        "max_tokens": 100
                    }
                },
                timeout=10
            )
            
            if response.status_code == 200:
                result = response.json()
                optimized = result.get("response", prompt).strip()
                logger.info(f"üéØ Prompt optimizado: {optimized}")
                return optimized
                
        except Exception as e:
            logger.warning(f"‚ö†Ô∏è Error optimizando prompt: {e}")
        
        # Fallback al prompt original
        return f"{style} {prompt}"
    
    async def _try_suno_generation(self, prompt: str, lyrics: str, style: str) -> Dict[str, Any]:
        """Intentar generaci√≥n con Suno usando sistema sigiloso"""
        
        try:
            logger.info(f"üéµ Intentando generaci√≥n Suno sigilosa: {prompt[:50]}...")
            
            # Usar el wrapper sigiloso para generaci√≥n real
            result = await generate_music_stealth(prompt, lyrics, style)
            
            if result and result.get("success"):
                logger.info("‚úÖ M√∫sica generada exitosamente con Suno sigiloso")
                return {
                    "success": True,
                    "track": result["track"]
                }
            else:
                logger.warning("‚ö†Ô∏è Generaci√≥n Suno fall√≥, usando fallback")
                return {"success": False, "error": "Suno generation failed"}
            
        except Exception as e:
            logger.warning(f"‚ö†Ô∏è Error en generaci√≥n Suno: {e}")
            return {"success": False, "error": str(e)}
    
    async def _generate_with_ollama_fallback(self, prompt: str, lyrics: str, style: str) -> Dict[str, Any]:
        """Generar m√∫sica usando Ollama como fallback"""
        
        logger.info("üîÑ Usando Ollama para generaci√≥n musical...")
        
        # Generar concepto musical con Ollama
        concept = await self._generate_music_concept_with_ollama(prompt, lyrics, style)
        
        # Generar audio sint√©tico (simulaci√≥n)
        audio_file = await self._generate_synthetic_audio(concept)
        
        return {
            "success": True,
            "track": {
                "id": f"ollama_{int(time.time())}",
                "title": concept.get("title", "M√∫sica generada por Ollama"),
                "filename": audio_file.name,
                "audio_url": f"/api/audio/stream/{audio_file.name}",
                "lyrics": concept.get("lyrics", lyrics),
                "prompt": prompt,
                "style": style,
                "created_at": datetime.now().isoformat(),
                "duration": 30,
                "download_url": f"/api/audio/download/{audio_file.name}",
                "suno_prompt": prompt,
                "is_simulation": True,
                "generated_by": "ollama"
            }
        }
    
    async def _generate_music_concept_with_ollama(self, prompt: str, lyrics: str, style: str) -> Dict[str, Any]:
        """Generar concepto musical detallado con Ollama"""
        
        # Traducir al ingl√©s para mejor procesamiento
        english_prompt = await self._translate_to_english(prompt)
        english_lyrics = await self._translate_to_english(lyrics) if lyrics else ""
        
        system_prompt = f"""Eres un compositor musical profesional. Crea un concepto musical natural y realista en INGL√âS basado en:

Prompt: {english_prompt}
Letra: {english_lyrics}
Estilo: {style}

Responde SOLO en formato JSON en INGL√âS:
{{
    "title": "Song title in English (maximum 6 words)",
    "genre": "Real music genre (pop, rock, folk, jazz, etc.)",
    "mood": "Natural mood (happy, sad, energetic, calm, etc.)",
    "lyrics": "Complete song lyrics in English",
    "tempo": "Tempo in BPM (80-160)",
    "key": "Musical key (C major, A minor, etc.)",
    "instruments": "Real instruments (guitar, piano, drums, bass, etc.)",
    "style_tags": "Real music style tags",
    "description": "Natural description of the musical concept"
}}

Use real music genres and natural descriptions, not technical or futuristic terms. Everything in English."""

        try:
            response = requests.post(
                f"{self.ollama_url}/api/generate",
                json={
                    "model": "llama3.1:latest",
                    "prompt": system_prompt,
                    "stream": False,
                    "options": {
                        "temperature": 0.8,
                        "top_p": 0.9,
                        "max_tokens": 500
                    }
                },
                timeout=15
            )
            
            if response.status_code == 200:
                result = response.json()
                concept_text = result.get("response", "{}").strip()
                
                # Limpiar respuesta de Ollama
                if concept_text.startswith("```json"):
                    concept_text = concept_text.replace("```json", "").replace("```", "").strip()
                
                try:
                    concept = json.loads(concept_text)
                    logger.info(f"üéº Concepto generado: {concept.get('title', 'Sin t√≠tulo')}")
                    return concept
                except json.JSONDecodeError:
                    logger.warning("‚ö†Ô∏è Error parseando JSON de Ollama")
            
        except Exception as e:
            logger.warning(f"‚ö†Ô∏è Error generando concepto: {e}")
        
        # Fallback b√°sico con conceptos naturales
        genre_map = {
            "pop": "pop",
            "rock": "rock", 
            "folk": "folk",
            "jazz": "jazz",
            "classical": "classical",
            "electronic": "electronic",
            "orchestral": "orchestral",
            "lofi": "lofi",
            "synthwave": "electronic",
            "cyberpunk": "electronic"
        }
        
        instrument_map = {
            "pop": "guitar, piano, drums, bass",
            "rock": "electric guitar, drums, bass",
            "folk": "acoustic guitar, violin, harmonica",
            "jazz": "piano, saxophone, double bass",
            "classical": "piano, strings, woodwinds",
            "orchestral": "orchestra, strings, brass",
            "electronic": "synthesizer, electronic drums",
            "lofi": "piano, soft drums, ambient sounds"
        }
        
        natural_genre = genre_map.get(style.lower(), "pop")
        natural_instruments = instrument_map.get(style.lower(), "guitar, piano, drums")
        
        return {
            "title": f"{prompt[:40].title()}",
            "genre": natural_genre,
            "mood": "happy",
            "lyrics": lyrics or f"Una canci√≥n sobre {prompt}",
            "tempo": "120 BPM",
            "key": "C major",
            "instruments": natural_instruments,
            "style_tags": f"{natural_genre}, {style}",
            "description": f"Canci√≥n {natural_genre} sobre {prompt}"
        }
    
    async def _generate_synthetic_audio(self, concept: Dict[str, Any]) -> Path:
        """Generar audio sint√©tico usando numpy (simulaci√≥n)"""
        
        try:
            import numpy as np
            from scipy.io import wavfile
            
            # Generar audio sint√©tico b√°sico
            sample_rate = 44100
            duration = 30  # segundos
            t = np.linspace(0, duration, int(sample_rate * duration), False)
            
            # Generar tono base
            frequency = 440  # La nota A4
            audio = np.sin(2 * np.pi * frequency * t)
            
            # Agregar variaci√≥n
            audio += 0.3 * np.sin(2 * np.pi * frequency * 2 * t)
            audio += 0.1 * np.sin(2 * np.pi * frequency * 4 * t)
            
            # Normalizar
            audio = audio / np.max(np.abs(audio))
            audio = (audio * 32767).astype(np.int16)
            
            # Guardar archivo
            filename = f"ollama_{int(time.time())}.wav"
            filepath = self.audio_dir / filename
            
            wavfile.write(filepath, sample_rate, audio)
            logger.info(f"üéµ Audio sint√©tico generado: {filename}")
            
            return filepath
            
        except ImportError:
            logger.warning("‚ö†Ô∏è numpy/scipy no disponible - creando archivo vac√≠o")
            # Crear archivo vac√≠o como fallback
            filename = f"ollama_{int(time.time())}.mp3"
            filepath = self.audio_dir / filename
            filepath.touch()
            return filepath
        except Exception as e:
            logger.error(f"‚ùå Error generando audio: {e}")
            # Fallback
            filename = f"ollama_{int(time.time())}.mp3"
            filepath = self.audio_dir / filename
            filepath.touch()
            return filepath
    
    def _fallback_response(self, error: str) -> Dict[str, Any]:
        """Respuesta de fallback cuando todo falla"""
        return {
            "success": False,
            "error": error,
            "track": None
        }
    
    async def get_connection_status(self) -> Dict[str, Any]:
        """Obtener estado de conexiones"""
        ollama_status = await self.check_ollama_health()
        suno_status = self.suno_credentials is not None
        
        return {
            "ollama_connected": ollama_status,
            "suno_configured": suno_status,
            "status": "active" if ollama_status else "inactive"
        }

# Instancia global
ollama_suno_proxy = OllamaSunoProxy()

# Funciones de conveniencia
async def generate_music_with_ollama_proxy(prompt: str, lyrics: str = "", style: str = "synthwave") -> Dict[str, Any]:
    """Funci√≥n de conveniencia para generar m√∫sica con el proxy Ollama-Suno"""
    return await ollama_suno_proxy.generate_music_via_ollama(prompt, lyrics, style)

def setup_ollama_suno_proxy(session_id: str, cookie: str, token: str = None):
    """Configurar el proxy con credenciales de Suno"""
    ollama_suno_proxy.setup_suno_credentials(session_id, cookie, token)

async def get_ollama_suno_status() -> Dict[str, Any]:
    """Obtener estado del proxy"""
    return await ollama_suno_proxy.get_connection_status()
